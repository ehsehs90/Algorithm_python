# 자료구조 힙(Heap) 이란?

- 완전 이진트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조이다.
- **여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아**내도록 만들어진 자료구조이다.
- 힙은 일종의 반정렬 상태(느슨한 정렬 상태) 를 유지한다
  - 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도
  - 간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진트리를 말한다
- 힙 트리에서는 중복된 값을 허용한다 ( 이진 탐색 트리에서는 중복된 값을 허용하지 않는다 )







## Heap 의 종류

- 최대 힙
  - 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진트리
  - KEY( 부모 노드 ) >= KEY( 자식 노드 )

- 최소 힙 

  - 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진트리
  - KEY(부모 노드) <= KEY( 자식 노드 )

  



## 힙의 구현

- 힙을 저장하는 표준적인 자료구조는 배열이다

- 구현을 쉽게 하기 위하여 배열의 첫번째 인덱스인 0은 사용하지 않는다

- 특정위치의 노드번호는 새로운 노드가 추가되어도 변하지 않는다

  - 예를들어 루트노드의 오른쪽 노드의 번호는 항상 3이다.

  

- 힙에서의 부모노드와 자식 노드의 관게
  - 왼쪽 자식의 인덱스 = 부모의 인덱스 * 2
  - 오른쪽 자식의 인덱스 = 부모의 인덱스 *2 + 1
  - 부모의 인덱스 = 자식의 인덱스 / 2
  - 

![image-20191123143548724](자료구조 힙(Heap).assets/image-20191123143548724.png)

## 힙 자료구조

- heapq 모듈은 이진트리(binary tree) 기반의 최소 힙(min heap) 자료구조를 제공한다
- min heap 을 사용하면 원소들이 항상 정렬된 상태로 추가되고 삭제되며, min heap 에서 가장 작은 값은 언제나 인덱스 0 , 즉 이진 트리 루트에 위치한다
- 내부적으로  min heap 내의 모든 원소 (k) 는 항상 자식 원소들 (  2k+1, 2k+2) 보다 크기가 작거나 같도록 원소가 추가되고 삭제된다



## 모듈 임포트

```python
import heapq
```



## 최소 힙 생성

- `heapq` 모듈은 파이썬의 보통 리스트를 마치 최소 힙 처럼 다룰 수 있도록 도와준다.
- 따라서 빈 리스트를 생성해 놓은 다음 `heapq` 모듈의 함수를 호출할 때마다 이 리스트를 인자로 넘겨야 한다
- 즉 파이썬에서는 `heapq` 모듈을 통해서 원소를 추가하거나 삭제한 리스트가 그냥 최소 힙이다.



## 힙에 원소 추가

`heapq` 모듈의 `heappush()` 함수를 이용하여 힙에 원소를 추가할 수 있다. 첫번째 인자는 원소를 추가할 대상 리스트이며 두번째 인자는 추가할 원소를 넘긴다.

```python
heapq.heappush(heap, 4)
heapq.heappush(heap, 1)
heapq.heappush(heap, 3)
heapq.heappush(heap, 6)
print(heap)
```

```python
[1,3,4,6]
```

가장작은 1 이 인덱스 0 에 위치하고, 인덱스 1에 위치한 `3`은 인덱스 3 에 위치한 `4`보다 크므로 힙의 공식을 만족한다.

내부적으로 이진 트리에 원소를 추가하는 `heappush()`함수는 `0(logN)`의 시간 복잡도를 가진다



## 힙에서 원소 삭제

`heapq` 모듈의 `heappop()` 함수를 이용하여 힙에서 원소를 삭제할 수 있다. 원소를 삭제할 대상 리스트를 인자로 넘기면, 가장 작은 원소를 삭제 후에 그 값을 리턴한다

```python
print(heapq.heappop(heap))
print(heap)
```

1

[3,4,6]



## 최소값 삭제하지 않고 얻기

힙에서 최소값을 삭제하지 않고 단순히 읽기만 하려면 일반적으로 리스트의 첫번째 원소에 접근하듯이 인덱스를 통해 접근하면 된다.

```python
print(heap[0])
```

여기서 주의사항은 인덱스 0에 가장 작은 원소가 있다고 해서, 인덱스 1에 두번째 작은 원소, 인덱스 2에 세번째 작은 원소가 있다는 보장은 없다는 것입니다.
왜냐하면 힙은 `heappop()` 함수를 호출하여 원소를 삭제할 때마다 이진 트리의 재배치를 통해 매번 새로운 최소값을 인덱스 0에 위치시키기 때문입니다.

따라서 두번째로 작은 원소를 얻으려면 바로 `heap[1]`으로 접근하면 안되고, 반드시 `heappop()`을 통해 가장 작은 원소를 삭제 후에 `heap[0]`를 통해 새로운 최소값에 접근해야 합니다.



## 기존 리스트를 힙으로 변환

이미 원소가 들어있는 리스트 힙으로 만들려면 `heapq` 모듈의 `heapify()` 라는 함수에 사용하면 된다

```python
heap = [4, 1, 7, 3, 8, 5]
heapq.heapify(heap)
print(heap)
```

```python
[1, 3, 5, 4, 8, 7]
```

 `heapify()` 함수에 리스트를 인자로 넘기면 리스트 내부의 원소들의 위에서 다룬 힙 구조에 맞게 재배치되며 최소값이 0번째 인덱스에 위치됩니다.
즉, 비어있는 리스트를 생성한 후 `heappush()` 함수로 원소를 하나씩 추가한 효과가 납니다.
`heapify()` 함수의 성능은 인자로 넘기는 리스트의 원소수에 비례합니다. 즉 `O(N)`의 시간 복잡도를 가집니다. 

## [응용] 최대 힙

`heapq` 모듈은 최소 힙(min heap)을 기능만을 동작하기 때문에 최대 힙(max heap)으로 활용하려면 약간의 요령이 필요합니다.
바로 힙에 튜플(tuple)를 원소로 추가하거나 삭제하면, 튜플 내에서 맨 앞에 있는 값을 기준으로 최소 힙이 구성되는 원리를 이용하는 것입니다.

따라서, 최대 힙을 만들려면 각 값에 대한 우선 순위를 구한 후, `(우선 순위, 값)` 구조의 튜플(tuple)을 힙에 추가하거나 삭제하면 됩니다.
그리고 힙에서 값을 읽어올 때는 각 튜플에서 인덱스 1에 있는 값을 취하면 됩니다. (우선 순위에는 관심이 없으므로 )

```python
import heapqnums = [4, 1, 7, 3, 8, 5]
heap = []
for num in nums:  
    heapq.heappush(heap, (-num, num))  # (우선 순위, 값)while heap:  print(heapq.heappop(heap)[1])  # index 1
875431
```

## [응용] K번째 최소값/최대값

최소 힙이나 최대 힙을 사용하면 K번째 최소값이나 최대값을 효츌적으로 구할 수 있습니다.

```python
import heapqdef kth_smallest(nums, k):  heap = []  
    for num in nums:    
        heapq.heappush(heap, num)  
        kth_min = None  
        for _ in range(k):    kth_min = heapq.heappop(heap)  
            return kth_min
        print(kth_smallest([4, 1, 7, 3, 8, 5], 3))
4
```

K번째 최소값을 구하기 위해서는 주어진 배열로 힙을 만든 후, `heappop()` 함수를 K번 호출하면 됩니다.

## [응용] 힙 정렬

힙 정렬(heap sort)은 위에서 설명드린 힙 자료구조의 성질을 이용한 대표적인 정렬 알고리즘입니다.

```python
import heapqdef heap_sort(nums):  heap = []  
    for num in nums:    
        heapq.heappush(heap, num)    sorted_nums = []  
        while heap:    
            sorted_nums.append(heapq.heappop(heap))  
            return sorted_nums
        
        print(heap_sort([4, 1, 7, 3, 8, 5]))
        
[1, 3, 4, 5, 7, 8]
```